package com.yyil.noteapp.mvc.model

import com.yyil.noteapp.entity.NoteContentEntity
import com.yyil.noteapp.entity.getNoteContentEntityFullCol
import java.sql.*

/**
 * holds a connection and some constants
 */
object Connect {
    private var dbNoteContent = "\"MAIN\".\"NOTE_CONTENT\""

//    var driver = "dm.jdbc.driver.DmDriver"
//    var databaseUserName = "SYSDBA"
//    var databasePassword = "1234567890"
//    var serverip = "5236"
//    //instanceName=SQLExpress;
//    var url = "jdbc:dm://IP:$serverip;databaseName=$dbName"

//    var driver = "dm.jdbc.driver.DmDriver"
//    var databaseUserName = "SYSDBA"
//    var databasePassword = "1234567890"

    const val serverip = "noteApp"
    private const val LOCAL_URL = "jdbc:sqlite:$serverip.db"
    var result: ResultSet? = null
    
    /**
     * Get a new Connection
     */
    fun getConnection(url:String = LOCAL_URL): Connection? {
        var conn: Connection? = null
        try {
            conn = DriverManager.getConnection(url)
            println("Connection to $url has been established.")
        } catch (e: SQLException) {
            println(e.message)
        }
        return conn
    }
    
    
    private fun getStmt(conn: Connection?): Statement? {
        return conn!!.createStatement()
    }

    /**
     * An example of ResultSet as well
     *  should be deleted before done
     */
    fun query(conn: Connection?) {
        try {
            if (conn != null) {
                val sql = "SELECT * FROM $dbNoteContent"
                val results = getStmt(conn)!!.executeQuery(sql)
                println("All notes:")
                while (results.next()) {
                    val noteId = results.getInt("NOTE_CONTENT_ID")
                    val repositoryPath = results.getString("REPOSITORY_PATH")
                    val noteContent = results.getString("NOTE_CONTENT")
                    println(noteId.toString() + "\t" + repositoryPath + "\t" + noteContent)
                }
            }
        } catch (ex: SQLException) {
            println(ex.message)
        }
    }

    /**
     * Insert a new noteContent into the db
     * nc: NoteContentEntity
     *      DO NOT assign nc.note_content_id as it will be generated by db
     */
    fun createContent(conn: Connection?, nc: NoteContentEntity): Boolean {
        if (nc.noteContentId != null) {
            return false
        }
        val barStr = nc.getInsertBraStr()
        val valueStr = nc.getInsertStr()
        println("$barStr\n$valueStr")
        val sql = "INSERT INTO $dbNoteContent($barStr) VALUES($valueStr)"
        getStmt(conn)!!.execute(sql)
        return true
    }

    /**
     * Update a noteContent by referring its primary key
     * nc: NoteContentEntity
     *      HAVE TO assign nc.note_content_id as it is the primary key, other fields will be considered as "changed"
     */
    fun updateContent(conn: Connection?, nc: NoteContentEntity): Boolean {
        if (nc.noteContentId == null) {
            return false
        }
        val setStr = nc.getUpdateStr()
        val id = nc.noteContentId
        val sql = "UPDATE $dbNoteContent SET $setStr where \"NOTE_CONTENT_ID\" = $id AND DEL_FLAG =  \"0\""
        getStmt(conn)!!.execute(sql)
        return true
    }

    /**
     * Find and return the result where the fields are EXACTLY SAME as nc
     * nc: NoteContentEntity
     *      nc.note_content_id != null: will find at most 1 row of result
     *      nc.note_content_id == null: will find all noteContents with the EXACTLY SAME fields
     *      conditions on fields are possible, and could be done if required
     * orders: String
     *      Please write the SQL like order to concat at the end of sql line, as things may change.
     *      Default to have a decreasing order on UPDATE_TIME and CREATE_TIME
     */
    fun findContent(conn: Connection?, nc: NoteContentEntity, orders: String = "UPDATE_TIME DESC, CREATE_TIME DESC"): ResultSet? {
        val condition = nc.getConStr()
        val sql =
            "SELECT " + getNoteContentEntityFullCol() + " FROM $dbNoteContent WHERE $condition AND DEL_FLAG = 0 ORDER BY $orders"
        result = getStmt(conn)!!.executeQuery(sql)
        return result
    }

    /**
     * LOGICALLY delete the noteContents where the fields are EXACTLY SAME as nc
     * nc: NoteContentEntity
     *      nc.note_content_id != null: will delete at most 1 row of result
     *      nc.note_content_id == null: will delete all noteContents with the EXACTLY SAME fields
     *      conditions on fields are possible, and could be done if required
     */
    fun deleteContent(conn: Connection?, nc: NoteContentEntity) {
        val condition = nc.getConStr()
        val sql = "UPDATE $dbNoteContent SET DEL_FLAG = 1 where  $condition AND DEL_FLAG = \"0\""
        getStmt(conn)!!.execute(sql)
    }
    
    /**
     * Reset the table NOTE_CONTENT to empty
     */
    fun resetContent(conn: Connection?) {
        val sql = "DELETE FROM $dbNoteContent"
        getStmt(conn)!!.execute(sql)
    }
    
    /**
     * Close the Connection conn
     */
    fun close(conn: Connection?) {
        try {
            if (conn != null) {
                conn.close()
                println("Connection $conn closed.")
            }
        } catch (ex: SQLException) {
            println(ex.message)
        }
    }
}
