package com.yyil.noteapp.mvc.model

import com.yyil.noteapp.entity.SQLEntity
import java.sql.*

const val SERVER_IP = "noteApp"
const val LOCAL_URL = "jdbc:sqlite:${SERVER_IP}.db"

object Connect {

//    var driver = "dm.jdbc.driver.DmDriver"
//    var databaseUserName = "SYSDBA"
//    var databasePassword = "1234567890"
//    var serverip = "5236"
//    //instanceName=SQLExpress;
//    var url = "jdbc:dm://IP:$serverip;databaseName=$dbName"

    //    var driver = "dm.jdbc.driver.DmDriver"
//    var databaseUserName = "SYSDBA"
//    var databasePassword = "1234567890"
    var conn: Connection? = null

    /**
     * Get a Connection to the database at url
     */
    fun getConnection(url: String = LOCAL_URL): Connection? {
        if (conn != null) return conn
        try {
            conn = DriverManager.getConnection(url)
            println("Connection to $url has been established.")
        } catch (e: SQLException) {
            println(e.message)
        }
        return conn
    }

    private fun getStmt(conn: Connection?): Statement? {
        return conn!!.createStatement()
    }

    /**
     * Insert a new noteContent into the db
     * en: SQLEntity
     *      DO NOT assign en's id as it will be generated by db
     */
    fun create(conn: Connection?, en: SQLEntity): Boolean {
        if (conn == null || en.getId() != null) {
            return false
        }
        val barStr = en.getInsertBraStr()
        val valueStr = en.getInsertStr()
        val dbName = en.getDbName()
//		println("$barStr\n$valueStr")
        val sql = "INSERT INTO $dbName ($barStr) VALUES($valueStr)"
        getStmt(conn)!!.execute(sql)
        return true
    }

    /**
     * Update a noteContent by referring its primary key
     * en: SQLEntity
     *      HAVE TO assign en's id as it is the primary key, other fields will be considered as "changed"
     */
    fun update(conn: Connection?, en: SQLEntity, condStr: String = ""): Boolean {
        if (conn == null || en.getId() == null) {
            return false
        }
        val setStr = en.getUpdateStr()
        val id = en.getId()
        val idName = en.getIdColumn()
        val dbName = en.getDbName()
        var sql = "UPDATE $dbName SET $setStr where \"$idName\" = $id"
        sql += if (condStr != "") "AND $condStr" else ""
        sql += " AND DEL_FLAG =  \"0\""
        getStmt(conn)!!.execute(sql)
        return true
    }

    /**
     * LOGICALLY delete the content where the fields are EXACTLY SAME as nc
     * en: SQLEntity
     *      en's id != null: will delete at most 1 row of result
     *      en's id == null: will delete all noteContents with the EXACTLY SAME fields
     *      conditions on fields are possible, and could be done if required
     */
    fun delete(conn: Connection?, en: SQLEntity) {
        val condition = en.getConStr()
        update(conn, en, condStr = condition)
    }


    /**
     * Delete every content from the dbName in conn
     */
    fun reset(conn: Connection?, dbName: String) {
        val sql = "DELETE FROM $dbName"
        getStmt(conn)!!.execute(sql)
    }

    /**
     * Delete every content from the table that en is in conn
     */
    fun reset(conn: Connection?, en: SQLEntity) {
        val dbName = en.getDbName()
        val sql = "DELETE FROM $dbName"
        getStmt(conn)!!.execute(sql)
    }

    /**
     * Find and return the result where the fields are EXACTLY SAME as en.
     * en: SQLEntity
     *      en's id != null: will find at most 1 row of result
     *      en's id == null: will find all noteContents with the EXACTLY SAME fields
     *      conditions on fields are possible and could be done if required
     * orders: String
     *      Please write the SQL-like order to concat at the end of SQL line, as things may change.
     *      Default to have a decreasing order on UPDATE_TIME and CREATE_TIME
     */
    fun find(
        conn: Connection?,
        en: SQLEntity,
        orders: String = "UPDATE_TIME DESC, CREATE_TIME DESC"
    ): ResultSet? {
        val dbName = en.getDbName()
        var condition = en.getConStr()
        condition = if (condition.isEmpty()) "" else "$condition AND "
        val sql =
            "SELECT " + en.getFullColumn() + " FROM $dbName WHERE $condition DEL_FLAG = 0 ORDER BY $orders"
//		println("sql: $sql")
        return getStmt(conn)!!.executeQuery(sql)
    }

    /**
     * Find and return all results where from the table with the name in the dbName.
     * dbName: String
     *      Database name
     * orders: String
     *      Please write the SQL-like order to concat at the end of SQL line, as things may change.
     *      Default to have a decreasing order on UPDATE_TIME and CREATE_TIME.
     */
    fun find(
        conn: Connection?,
        dbName: String,
        orders: String = "UPDATE_TIME DESC, CREATE_TIME DESC"
    ): ResultSet? {
        val sql =
            "SELECT * FROM $dbName WHERE DEL_FLAG = 0 ORDER BY $orders"
//		println("SQL in find by dbName: $sql")
        return getStmt(conn)!!.executeQuery(sql)
    }

    /**
     * Close the Connection conn
     */
    fun close(conn: Connection?) {
        try {
            if (conn != null) {
                conn.close()
                println("Connection $conn closed.")
            }
        } catch (ex: SQLException) {
            println(ex.message)
        }
    }
}
