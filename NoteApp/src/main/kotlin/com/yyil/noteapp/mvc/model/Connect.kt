package com.yyil.noteapp.mvc.model

import com.yyil.noteapp.entity.NoteContentEntity
import com.yyil.noteapp.entity.SQLEntity
import com.yyil.noteapp.entity.SettingEntity
import java.sql.*

const val SERVER_IP = "noteApp"
const val LOCAL_URL = "jdbc:sqlite:${SERVER_IP}.db"

object Connect {

//    var driver = "dm.jdbc.driver.DmDriver"
//    var databaseUserName = "SYSDBA"
//    var databasePassword = "1234567890"
//    var serverip = "5236"
//    //instanceName=SQLExpress;
//    var url = "jdbc:dm://IP:$serverip;databaseName=$dbName"

    //    var driver = "dm.jdbc.driver.DmDriver"
//    var databaseUserName = "SYSDBA"
//    var databasePassword = "1234567890"
    var conn: Connection? = null

    /**
     * Get a Connection to the database at url
     */
    fun getConnection(url: String = LOCAL_URL): Connection? {
        if (conn != null) return conn
        try {
            conn = DriverManager.getConnection(url)
            println("Connection to $url has been established.")
        } catch (e: SQLException) {
            println(e.message)
        }
        return conn
    }

    private fun getStmt(conn: Connection?): Statement? {
        return conn!!.createStatement()
    }

    /**
     * Insert a new noteContent into the db
     * Params: en - SQLEntity
     *      DO NOT assign en's id as it will be generated by db
     * Returns: either (1) the last insert id
     *                 (2) 0 indicates that create failed
     */
    fun create(conn: Connection?, en: SQLEntity): Int {
        if (conn == null || en.getId() != null) {
            return 0
        }
        val barStr = en.getInsertBraStr()
        val valueStr = en.getInsertStr()
        val dbName = en.getDbName()
        val sql = "INSERT INTO $dbName ($barStr) VALUES($valueStr)"
        println(sql)
        val check = getStmt(conn)!!.executeUpdate(sql)
        if (check == 0) {
            return 0
        }
        val rs = getStmt(conn)!!.executeQuery("SELECT last_insert_rowid() \"NEWID\"")
        println(rs)
        return rs!!.getInt("NEWID")
    }

    /**
     * Update a noteContent by referring its primary key.
     * NOTE: HAVE TO assign en's id as it is the primary key, other fields will be considered as "changed".
     * Params: en - SQLEntity
     *         condStr - String, which is the additional condition for update
     * Returns: either (1) the row count for SQL Data Manipulation Language (DML) statements or
     *                 (2) 0 for SQL statements that return nothing
     */
    fun update(conn: Connection?, en: SQLEntity, condStr: String = ""): Int {
        if (conn == null || en.getId() == null) {
            return 0
        }
        en.updateTime(Timestamp(System.currentTimeMillis()).toString())
        val setStr = en.getUpdateStr()
        val dbName = en.getDbName()
        val id = en.getId()
        val colName = en.getIdColumn()
        var sql = "UPDATE $dbName SET $setStr "
        if (id != null) {
            sql += " WHERE $colName = $id "
        } else if (condStr !== null) {
            sql += " WHERE $colName = $id "
        } else {
            sql += " WHERE 1 = 1 "
        }
        sql += " AND DEL_FLAG =  \"0\""
        println(sql)
        return getStmt(conn)!!.executeUpdate(sql)
    }

    /**
     * LOGICALLY delete the content where the fields are EXACTLY SAME as nc.
     * NOTE: WHEN en's id != null: will delete at most 1 row of result;
     *            en's id == null: will delete all noteContents with the EXACTLY SAME fields.
     *       conditions on fields are possible, and could be done if required
     * Params:
     *       conn - Connection?
     *       en - SQLEntity
     * Returns: either (1) the row count for SQL Data Manipulation Language (DML) statements or
     *                 (2) 0 for SQL statements that return nothing
     */
    fun delete(conn: Connection?, en: SQLEntity): Int {
        en.setDel()
        return update(conn, en)
    }

    /**
     * LOGICALLY delete the note content with note's id = id.
     * Params:
     *       conn - Connection?
     *       en - SQLEntity
     * Returns: either (1) the row count for SQL Data Manipulation Language (DML) statements or
     *                 (2) 0 for SQL statements that return nothing
     */
    fun deleteNoteById(conn: Connection?, id: Int): Int {
        return delete(conn, en = NoteContentEntity(noteContentId = id))
    }


    /**
     * Delete every content from the dbName in conn
     */
    fun reset(conn: Connection?, dbName: String) {
        val sql = "DELETE FROM $dbName"
        getStmt(conn)!!.execute(sql)
    }

    /**
     * Delete every content from the table that en is in conn
     */
    fun reset(conn: Connection?, en: SQLEntity) {
        val dbName = en.getDbName()
        val sql = "DELETE FROM $dbName"
        getStmt(conn)!!.execute(sql)
    }

    /**
     * Find and return the ResultSet where the fields are EXACTLY SAME as en.
     * Params:
     * conn - Connection?
     * en - SQLEntity
     *      en's id != null: will find at most 1 row of result
     *      en's id == null: will find all noteContents with the EXACTLY SAME fields
     *      conditions on fields are possible and could be done if required
     * orders - String
     *      Please write the SQL-like order to concat at the end of SQL line, as things may change.
     *      Default to have a decreasing order on UPDATE_TIME and CREATE_TIME
     */
    fun find(
        conn: Connection?, en: SQLEntity, orders: String = "UPDATE_TIME DESC, CREATE_TIME DESC"
    ): ResultSet? {
        val dbName = en.getDbName()
        var condition = en.getConStr()
        condition = if (condition.isEmpty()) "" else "$condition AND "
        val sql = "SELECT " + en.getFullColumn() + " FROM $dbName WHERE $condition DEL_FLAG = 0 ORDER BY $orders"
        println("sql: $sql")
        return getStmt(conn)!!.executeQuery(sql)
    }

    /**
     * Find and return A MutableList<NoteContentEntity> where the fields are EXACTLY SAME as en.
     * Params:
     *        conn - Connection?
     *        en - NoteContentEntity
     *             en's id != null: will find at most 1 row of result
     *             en's id == null: will find all noteContents with the EXACTLY SAME fields
     *        orders - String
     *             Please write the SQL-like order to concat at the end of SQL line, as things may change.
     *             Default to have a decreasing order on UPDATE_TIME and CREATE_TIME
     * Returns: either (1) A MutableList<NoteContentEntity>, if select success
     *                 (2) null, if nothing is fetched
     */
    fun findNoteFullList(
        conn: Connection?, en: NoteContentEntity, orders: String = "UPDATE_TIME DESC, CREATE_TIME DESC"
    ): MutableList<NoteContentEntity>? {
        val eList = mutableListOf<NoteContentEntity>()
        var re: NoteContentEntity
        val rs: ResultSet = find(conn, en, orders) ?: return null
        while (rs.next()) {
            re = NoteContentEntity()
            re.noteContentId = rs.getInt("NOTE_CONTENT_ID")
            re.creator = rs.getString("CREATOR")
            re.createTime = rs.getString("CREATE_TIME")
            re.updater = rs.getString("UPDATER")
            re.updateTime = rs.getString("UPDATE_TIME")
            re.repositoryPath = rs.getString("REPOSITORY_PATH")
            re.noteContent = rs.getString("NOTE_CONTENT")
            re.category = rs.getString("CATEGORY")
            re.title = rs.getString("TITLE")
            eList.add(re)
        }
        return eList
    }


    /**
     * Find and return A MutableList<NoteContentEntity> where the fields are EXACTLY SAME as en.
     * Params:
     *        conn - Connection?
     *        en - NoteContentEntity
     *             en's id != null: will find at most 1 row of result
     *             en's id == null: will find all noteContents with the EXACTLY SAME fields
     *        orders - String
     *             Please write the SQL-like order to concat at the end of SQL line, as things may change.
     *             Default to have a decreasing order on UPDATE_TIME and CREATE_TIME
     * Returns: either (1) A MutableList<NoteContentEntity> which contains only id and title fields, if select successes
     *                 (2) null, if nothing is fetched
     */
    fun findNoteTitleList(
        conn: Connection?, en: NoteContentEntity, orders: String = "UPDATE_TIME DESC, CREATE_TIME DESC"
    ): MutableList<NoteContentEntity>? {
        val eList = mutableListOf<NoteContentEntity>()
        var re: NoteContentEntity
        val dbName = en.getDbName()
        var condition = en.getConStr()
        condition = if (condition.isEmpty()) "" else "$condition AND "
        val sql = "SELECT " + en.getTiTleStr() + " FROM $dbName WHERE $condition DEL_FLAG = 0 ORDER BY $orders"
        val rs: ResultSet = getStmt(conn)!!.executeQuery(sql)
        while (rs.next()) {
            re = NoteContentEntity()
            re.noteContentId = rs.getInt("NOTE_CONTENT_ID")
            re.category = rs.getString("CATEGORY")
            re.title = rs.getString("TITLE")
            eList.add(re)
        }
        return eList
    }

    /**
     * Find and return the NoteContentEntity with id in the db.
     * Params: id - Int
     *         db: String
     * Returns: either (1) A NoteContentEntity, if select success
     *                 (2) null, if nothing is fetched
     */
    fun findNoteById(
        conn: Connection?, id: Int
    ): NoteContentEntity? {
        val lst = findNoteFullList(conn, NoteContentEntity(noteContentId = id))
        if (lst?.size!! > 0) {
            return findNoteFullList(conn, NoteContentEntity(noteContentId = id))?.get(0)
        }
        return null
    }

    /**
     * Find and return A MutableList<SettingEntity> where the fields are EXACTLY SAME as en.
     * Params:
     *        conn - Connection?
     *        en - SettingEntity
     *             en's id != null: will find at most 1 row of result
     *             en's id == null: will find all settings with the EXACTLY SAME fields
     *        orders - String
     *             Please write the SQL-like order to concat at the end of SQL line, as things may change.
     *             Default to have a decreasing order on UPDATE_TIME and CREATE_TIME
     * Returns: either (1) A MutableList<SettingEntity>, if select success
     *                 (2) null, if nothing is fetched
     */
    fun findSettingFullList(
        conn: Connection?, en: SettingEntity, orders: String = "UPDATE_TIME DESC, CREATE_TIME DESC"
    ): MutableList<SettingEntity>? {
        val eList = mutableListOf<SettingEntity>()
        var re: SettingEntity
        val rs: ResultSet = find(conn, en, orders) ?: return null
        while (rs.next()) {
            re = SettingEntity()
            re.settingId = rs.getInt("SETTING_ID")
            re.creator = rs.getString("CREATOR")
            re.createTime = rs.getString("CREATE_TIME")
            re.updater = rs.getString("UPDATER")
            re.updateTime = rs.getString("UPDATE_TIME")
            re.name = rs.getString("NAME")
            re.value = rs.getString("VALUE")
            eList.add(re)
        }
        return eList
    }

    /**
     * Find and return the SettingEntity with id in the db.
     * Params: id - Int
     * Returns: either (1) A SettingEntity, if select success
     *                 (2) null, if nothing is fetched
     */
    fun findSettingById(
        conn: Connection?, id: Int
    ): SettingEntity? {
        val lst = findSettingFullList(conn, SettingEntity(settingId = id))
        if (lst?.size!! > 0) {
            return findSettingFullList(conn, SettingEntity(settingId = id))?.get(0)
        }
        return null
    }

    /**
     * Find and return the SettingEntity with name in the db.
     * Params: name: String
     * Returns: either (1) A SettingEntity, if select success
     *                 (2) null, if nothing is fetched
     */
    fun findSettingByName(
        conn: Connection?, name: String
    ): SettingEntity? {
        val lst = findSettingFullList(conn, SettingEntity(name = name))
        if (lst?.size!! > 0) {
            return findSettingFullList(conn, SettingEntity(name = name))?.get(0)
        }
        return null
    }

    /**
     * Find and return all results where from the table with the name in the dbName.
     * Params:
     *      dbName - String
     *           Database name
     *      orders - String
     *           Please write the SQL-like order to concat at the end of SQL line, as things may change.
     *           Default to have a decreasing order on UPDATE_TIME and CREATE_TIME.
     */
    fun loadAll(
        conn: Connection?, dbName: String, orders: String = "UPDATE_TIME DESC, CREATE_TIME DESC"
    ): ResultSet? {
        val sql = "SELECT * FROM $dbName WHERE DEL_FLAG = 0 ORDER BY $orders"
//		println("SQL in find by dbName: $sql")
        return getStmt(conn)!!.executeQuery(sql)
    }

    /**
     * Close the Connection conn
     */
    fun close(conn: Connection?) {
        try {
            if (conn != null) {
                conn.close()
                println("Connection $conn closed.")
            }
        } catch (ex: SQLException) {
            println(ex.message)
        }
    }
}
